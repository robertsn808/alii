const { Octokit } = require('@octokit/rest');
const simpleGit = require('simple-git');
const fs = require('fs').promises;
const path = require('path');

class GitHubIntegration {
  constructor(config) {
    this.config = config;
    this.octokit = new Octokit({
      auth: process.env.GITHUB_TOKEN
    });
    
    this.repoOwner = config.repoOwner || process.env.GITHUB_REPO_OWNER;
    this.repoName = config.repoName || process.env.GITHUB_REPO_NAME;
    this.projectRoot = config.projectRoot || '../..';
    
    this.git = simpleGit(this.projectRoot);
    this.prTemplates = this.loadPRTemplates();
  }

  loadPRTemplates() {
    return {
      bugfix: {
        title: 'ðŸ› Auto-fix: {error_type} - {short_description}',
        labels: ['bug', 'auto-fix', 'ai-generated'],
        reviewers: ['robertsn808'], // Add your GitHub username
        template: `
## ðŸ¤– AI-Generated Bug Fix

**Error Analysis ID:** {analysis_id}
**Fix Confidence:** {confidence}%
**Priority:** {priority}

### ðŸ› Problem
{error_description}

**Error Type:** {error_type}
**Affected Service:** {service}
**Severity:** {severity}

### ðŸ”§ Solution
{fix_description}

**AI Analysis Summary:**
{ai_summary}

### ðŸ“ Files Changed
{files_changed}

### ðŸ§ª Testing
{testing_plan}

### ðŸ”’ Safety Measures
- [x] Automated testing included
- [x] Rollback plan documented
- [x] Impact assessment completed
- [ ] Manual review required

### ðŸ“Š Business Impact
**Alii Fish Market Toast POS Replacement Impact:**
- **Revenue Impact:** {revenue_impact}
- **Operations Impact:** {operations_impact}
- **Customer Experience:** {customer_impact}

---
*This PR was automatically generated by the AI Error Monitoring System*
*Analysis powered by Claude and OpenAI*
        `
      },
      hotfix: {
        title: 'ðŸš¨ HOTFIX: Critical {error_type} - {short_description}',
        labels: ['hotfix', 'critical', 'auto-fix'],
        reviewers: ['robertsn808'],
        template: `
## ðŸš¨ CRITICAL HOTFIX - Immediate Action Required

**Error Analysis ID:** {analysis_id}
**Fix Confidence:** {confidence}%
**Priority:** CRITICAL

### âš ï¸ Critical Issue
{error_description}

**Impact on Alii Fish Market:**
- Payment processing affected: {payment_impact}
- Customer orders affected: {order_impact}
- Revenue at risk: {revenue_risk}

### ðŸ”§ Immediate Fix
{fix_description}

### ðŸ“ Files Changed
{files_changed}

### ðŸ§ª Validation
- [x] AI-generated tests included
- [x] Fix verified by multiple AI models
- [ ] **MANUAL TESTING REQUIRED BEFORE MERGE**

### ðŸš€ Deployment Notes
{deployment_notes}

---
**â° URGENT:** This hotfix addresses a critical issue affecting the Toast POS replacement system.
        `
      },
      improvement: {
        title: 'âœ¨ Auto-improvement: {error_type} - {short_description}',
        labels: ['enhancement', 'auto-fix', 'improvement'],
        reviewers: [],
        template: `
## âœ¨ AI-Generated System Improvement

**Error Analysis ID:** {analysis_id}
**Fix Confidence:** {confidence}%

### ðŸ“ˆ Improvement Description
{fix_description}

### ðŸŽ¯ Benefits
- Enhanced error handling
- Improved system reliability
- Better user experience

### ðŸ“ Files Changed
{files_changed}

### ðŸ§ª Testing
{testing_plan}

---
*Automated improvement suggestion for the Alii Fish Market UPP system*
        `
      }
    };
  }

  async createFixPullRequest(fixResult, errorAnalysis) {
    try {
      const branchName = this.generateBranchName(fixResult, errorAnalysis);
      const prData = this.preparePRData(fixResult, errorAnalysis);
      
      // Create branch and apply changes
      await this.createBranch(branchName);
      await this.applyCodeChanges(fixResult.codeChanges);
      await this.commitChanges(branchName, prData.commitMessage);
      await this.pushBranch(branchName);
      
      // Create pull request
      const pr = await this.createPullRequest(branchName, prData);
      
      // Add reviewers and labels
      await this.configurePullRequest(pr.number, prData);
      
      // Add detailed comment with analysis
      await this.addAnalysisComment(pr.number, fixResult, errorAnalysis);
      
      return {
        success: true,
        pullRequest: pr,
        branch: branchName,
        url: pr.html_url
      };
    } catch (error) {
      console.error('Error creating pull request:', error);
      return {
        success: false,
        error: error.message,
        rollback: await this.rollbackBranch(branchName)
      };
    }
  }

  generateBranchName(fixResult, errorAnalysis) {
    const errorType = errorAnalysis.error.type;
    const timestamp = new Date().toISOString().substr(0, 10);
    const shortId = fixResult.id.substr(-8);
    
    return `ai-fix/${errorType}-${timestamp}-${shortId}`;
  }

  preparePRData(fixResult, errorAnalysis) {
    const templateType = this.selectPRTemplate(errorAnalysis);
    const template = this.prTemplates[templateType];
    
    const prData = {
      title: this.fillTemplate(template.title, {
        error_type: errorAnalysis.error.type,
        short_description: this.createShortDescription(errorAnalysis.error.message)
      }),
      body: this.fillTemplate(template.template, {
        analysis_id: errorAnalysis.id,
        confidence: Math.round(fixResult.recommendedApproach.confidence * 100),
        priority: this.formatPriority(errorAnalysis.priority),
        error_description: errorAnalysis.error.message,
        error_type: errorAnalysis.error.type,
        service: errorAnalysis.error.service,
        severity: errorAnalysis.error.severity,
        fix_description: this.formatFixDescription(fixResult),
        ai_summary: this.formatAISummary(errorAnalysis),
        files_changed: this.formatFilesChanged(fixResult.codeChanges),
        testing_plan: this.formatTestingPlan(fixResult.testCases),
        revenue_impact: errorAnalysis.businessImpact.revenue,
        operations_impact: errorAnalysis.businessImpact.operations,
        customer_impact: this.assessCustomerImpact(errorAnalysis),
        payment_impact: this.assessPaymentImpact(errorAnalysis),
        order_impact: this.assessOrderImpact(errorAnalysis),
        revenue_risk: this.calculateRevenueRisk(errorAnalysis),
        deployment_notes: this.formatDeploymentNotes(fixResult)
      }),
      labels: template.labels,
      reviewers: template.reviewers,
      commitMessage: `AI-Fix: ${errorAnalysis.error.type} - ${this.createShortDescription(errorAnalysis.error.message)}\n\nFix generated by AI Error Monitoring System\nAnalysis ID: ${errorAnalysis.id}\nConfidence: ${Math.round(fixResult.recommendedApproach.confidence * 100)}%`
    };
    
    return prData;
  }

  selectPRTemplate(errorAnalysis) {
    if (errorAnalysis.priority === 1 || errorAnalysis.error.severity === 'critical') {
      return 'hotfix';
    } else if (errorAnalysis.error.severity === 'high' || errorAnalysis.error.type === 'payment') {
      return 'bugfix';
    } else {
      return 'improvement';
    }
  }

  fillTemplate(template, variables) {
    let filled = template;
    for (const [key, value] of Object.entries(variables)) {
      filled = filled.replace(new RegExp(`{${key}}`, 'g'), value || 'N/A');
    }
    return filled;
  }

  createShortDescription(message) {
    return message.length > 50 ? message.substr(0, 47) + '...' : message;
  }

  formatPriority(priority) {
    const priorities = { 1: 'CRITICAL', 2: 'HIGH', 3: 'MEDIUM', 4: 'LOW' };
    return priorities[priority] || 'MEDIUM';
  }

  formatFixDescription(fixResult) {
    const approach = fixResult.recommendedApproach;
    return `**Provider:** ${approach.provider}\n**Approach:** ${approach.approach}\n**Description:** ${approach.fix.description || 'Automated code fix'}`;
  }

  formatAISummary(errorAnalysis) {
    const claude = errorAnalysis.analysis.claude;
    const openai = errorAnalysis.analysis.openai;
    
    return `
**Claude Analysis:** ${claude?.analysis?.rootCause || 'N/A'}

**OpenAI Analysis:** ${openai?.analysis?.diagnosis || 'N/A'}

**Consensus:** ${errorAnalysis.analysis.consensus.commonThemes.join(', ') || 'No clear consensus'}

**Confidence Level:** ${Math.round(errorAnalysis.analysis.confidence * 100)}%
    `;
  }

  formatFilesChanged(codeChanges) {
    return codeChanges.map(change => 
      `- \`${change.filePath}\`: ${change.description} (**${change.priority}** priority)`
    ).join('\n');
  }

  formatTestingPlan(testCases) {
    if (testCases.length === 0) return 'Manual testing required';
    
    return testCases.map(test => 
      `- **${test.type}** test for \`${test.target}\`: ${test.description}`
    ).join('\n');
  }

  assessCustomerImpact(errorAnalysis) {
    if (errorAnalysis.error.type === 'payment') return 'High - Payment processing affected';
    if (errorAnalysis.error.type === 'api') return 'Medium - API functionality may be limited';
    return 'Low - Backend issue with minimal customer visibility';
  }

  assessPaymentImpact(errorAnalysis) {
    return errorAnalysis.error.type === 'payment' ? 'YES - UPP/Stripe processing affected' : 'NO';
  }

  assessOrderImpact(errorAnalysis) {
    const orderRelated = ['payment', 'database', 'api'];
    return orderRelated.includes(errorAnalysis.error.type) ? 'YES - Order flow may be affected' : 'NO';
  }

  calculateRevenueRisk(errorAnalysis) {
    if (errorAnalysis.error.type === 'payment' && errorAnalysis.error.severity === 'critical') {
      return 'HIGH - Complete payment processing failure';
    } else if (errorAnalysis.error.type === 'payment') {
      return 'MEDIUM - Partial payment processing impact';
    }
    return 'LOW - No direct revenue impact';
  }

  formatDeploymentNotes(fixResult) {
    const notes = [];
    
    if (fixResult.estimatedImpact.riskLevel === 'high') {
      notes.push('âš ï¸  High-risk deployment - Deploy during low traffic hours');
    }
    
    if (fixResult.validation.manual) {
      notes.push('ðŸ‘¥ Manual validation required before deployment');
    }
    
    if (fixResult.estimatedImpact.testingRequired) {
      notes.push('ðŸ§ª Run full test suite before deployment');
    }
    
    notes.push(`ðŸ“Š Rollback complexity: ${fixResult.rollbackPlan.rollbackComplexity}`);
    
    return notes.join('\n');
  }

  async createBranch(branchName) {
    try {
      await this.git.checkoutLocalBranch(branchName);
    } catch (error) {
      // If branch creation fails, try to checkout existing branch
      await this.git.checkout(branchName);
    }
  }

  async applyCodeChanges(codeChanges) {
    for (const change of codeChanges) {
      try {
        await this.applyCodeChange(change);
      } catch (error) {
        console.error(`Error applying change to ${change.filePath}:`, error);
        throw new Error(`Failed to apply change to ${change.filePath}: ${error.message}`);
      }
    }
  }

  async applyCodeChange(change) {
    const filePath = path.resolve(this.projectRoot, change.filePath);
    
    if (change.changeType === 'create') {
      await fs.writeFile(filePath, change.codeBlock);
    } else if (change.changeType === 'modify') {
      const currentContent = await fs.readFile(filePath, 'utf8');
      const newContent = this.applyModification(currentContent, change);
      await fs.writeFile(filePath, newContent);
    }
  }

  applyModification(currentContent, change) {
    // This is a simplified implementation
    // In production, you'd want more sophisticated code patching
    
    if (change.codeBlock && change.codeBlock.includes('// REPLACE:')) {
      const parts = change.codeBlock.split('// REPLACE:');
      if (parts.length === 2) {
        const [oldCode, newCode] = parts.map(p => p.trim());
        return currentContent.replace(oldCode, newCode);
      }
    }
    
    // For now, append the new code at the end
    return currentContent + '\n\n// AI-Generated Fix\n' + change.codeBlock;
  }

  async commitChanges(branchName, commitMessage) {
    await this.git.add('.');
    await this.git.commit(commitMessage);
  }

  async pushBranch(branchName) {
    await this.git.push('origin', branchName);
  }

  async createPullRequest(branchName, prData) {
    const response = await this.octokit.pulls.create({
      owner: this.repoOwner,
      repo: this.repoName,
      title: prData.title,
      head: branchName,
      base: 'main',
      body: prData.body,
      draft: false
    });
    
    return response.data;
  }

  async configurePullRequest(prNumber, prData) {
    // Add labels
    if (prData.labels.length > 0) {
      await this.octokit.issues.addLabels({
        owner: this.repoOwner,
        repo: this.repoName,
        issue_number: prNumber,
        labels: prData.labels
      });
    }
    
    // Request reviewers
    if (prData.reviewers.length > 0) {
      await this.octokit.pulls.requestReviewers({
        owner: this.repoOwner,
        repo: this.repoName,
        pull_number: prNumber,
        reviewers: prData.reviewers
      });
    }
  }

  async addAnalysisComment(prNumber, fixResult, errorAnalysis) {
    const comment = this.buildAnalysisComment(fixResult, errorAnalysis);
    
    await this.octokit.issues.createComment({
      owner: this.repoOwner,
      repo: this.repoName,
      issue_number: prNumber,
      body: comment
    });
  }

  buildAnalysisComment(fixResult, errorAnalysis) {
    return `
## ðŸ¤– Detailed AI Analysis

### ðŸ“Š Analysis Metrics
- **Claude Confidence:** ${Math.round(errorAnalysis.analysis.claude?.confidence * 100 || 0)}%
- **OpenAI Confidence:** ${Math.round(errorAnalysis.analysis.openai?.confidence * 100 || 0)}%
- **Overall Confidence:** ${Math.round(errorAnalysis.analysis.confidence * 100)}%
- **Estimated Fix Time:** ${errorAnalysis.estimatedFixTime}

### ðŸŽ¯ Fix Approaches Considered
${fixResult.approaches.map(approach => 
  `**${approach.provider}** (${approach.approach}): ${Math.round(approach.confidence * 100)}% confidence`
).join('\n')}

### ðŸ—ï¸ Impact Assessment
- **Risk Level:** ${fixResult.estimatedImpact.riskLevel}
- **Files Changed:** ${fixResult.estimatedImpact.filesChanged}
- **Affected Features:** ${fixResult.estimatedImpact.affectedFeatures.join(', ')}
- **Testing Required:** ${fixResult.estimatedImpact.testingRequired ? 'YES' : 'NO'}

### ðŸ’¼ Business Context - Alii Fish Market
This fix contributes to the Toast POS replacement system:
- **Annual Cost Savings:** $6,132 (31% reduction)
- **Payment System:** Universal Payment Protocol (UPP)
- **Deployment:** Render.com (aliifishmarket.realconnect.online)

### ðŸ”„ Rollback Plan
- **Backup Required:** ${fixResult.rollbackPlan.backupRequired ? 'YES' : 'NO'}
- **Automated Rollback:** ${fixResult.rollbackPlan.automatedRollback ? 'YES' : 'NO'}
- **Manual Steps Required:** ${fixResult.rollbackPlan.manualStepsRequired ? 'YES' : 'NO'}

---
*Generated by AI Error Monitoring System v1.0*
*Timestamp: ${new Date().toISOString()}*
    `;
  }

  async rollbackBranch(branchName) {
    try {
      await this.git.checkout('main');
      await this.git.deleteLocalBranch(branchName);
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async createIssue(errorAnalysis, fixResult = null) {
    const issue = await this.octokit.issues.create({
      owner: this.repoOwner,
      repo: this.repoName,
      title: `ðŸ› Error Detected: ${errorAnalysis.error.type} - ${this.createShortDescription(errorAnalysis.error.message)}`,
      body: this.buildIssueBody(errorAnalysis, fixResult),
      labels: this.getIssueLabels(errorAnalysis)
    });
    
    return issue.data;
  }

  buildIssueBody(errorAnalysis, fixResult) {
    return `
## ðŸ› Error Report

**Analysis ID:** ${errorAnalysis.id}
**Detected:** ${errorAnalysis.timestamp}
**Priority:** ${this.formatPriority(errorAnalysis.priority)}

### Error Details
- **Type:** ${errorAnalysis.error.type}
- **Severity:** ${errorAnalysis.error.severity}
- **Service:** ${errorAnalysis.error.service}
- **Message:** ${errorAnalysis.error.message}

### AI Analysis Summary
${this.formatAISummary(errorAnalysis)}

### Business Impact
- **Revenue:** ${errorAnalysis.businessImpact.revenue}
- **Operations:** ${errorAnalysis.businessImpact.operations}
- **Customer Experience:** ${this.assessCustomerImpact(errorAnalysis)}

${fixResult ? `
### ðŸ¤– Automated Fix Available
An automated fix has been generated with ${Math.round(fixResult.recommendedApproach.confidence * 100)}% confidence.
The fix involves ${fixResult.codeChanges.length} file(s) and has been tested.

**Fix ID:** ${fixResult.id}
` : ''}

---
*Reported by AI Error Monitoring System*
    `;
  }

  getIssueLabels(errorAnalysis) {
    const labels = ['bug', 'auto-detected'];
    
    if (errorAnalysis.priority === 1) labels.push('critical');
    if (errorAnalysis.error.severity === 'high') labels.push('high-priority');
    if (errorAnalysis.error.type === 'payment') labels.push('payment');
    if (errorAnalysis.error.type === 'security') labels.push('security');
    
    return labels;
  }

  async getRepositoryInfo() {
    const repo = await this.octokit.repos.get({
      owner: this.repoOwner,
      repo: this.repoName
    });
    
    return repo.data;
  }

  async listOpenPRs() {
    const prs = await this.octokit.pulls.list({
      owner: this.repoOwner,
      repo: this.repoName,
      state: 'open'
    });
    
    return prs.data;
  }

  async checkPRStatus(prNumber) {
    const pr = await this.octokit.pulls.get({
      owner: this.repoOwner,
      repo: this.repoName,
      pull_number: prNumber
    });
    
    return {
      status: pr.data.state,
      mergeable: pr.data.mergeable,
      merged: pr.data.merged,
      checks: await this.getPRChecks(prNumber)
    };
  }

  async getPRChecks(prNumber) {
    try {
      const checks = await this.octokit.checks.listForRef({
        owner: this.repoOwner,
        repo: this.repoName,
        ref: `pull/${prNumber}/head`
      });
      
      return checks.data.check_runs.map(check => ({
        name: check.name,
        status: check.status,
        conclusion: check.conclusion
      }));
    } catch (error) {
      return [];
    }
  }
}

module.exports = GitHubIntegration;